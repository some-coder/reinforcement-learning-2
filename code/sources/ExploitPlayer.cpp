#include "ExploitPlayer.hpp"

/**
 * Constructs an exploit player.
 *
 * @param m The maze for the player to solve.
 * @param policy The policy used to solve the maze with.
 */
ExploitPlayer::ExploitPlayer(Maze *m, std::map<State*, std::vector<double>> policy) : Player(m) {
    this->currentEpoch = 0;
    this->timeoutEpoch = std::ceil(Player::EPISODE_TIMEOUT_FRACTION * this->maze->getStates()->size());
    this->policy = std::move(policy);
}

/**
 * Destructs the exploit player.
 */
ExploitPlayer::~ExploitPlayer() = default;

/**
 * Obtains the first state-action pair for an episode generation.
 *
 * @return The initial state-action pair.
 */
State *ExploitPlayer::initialState() {
    return this->maze->getStartingState();
}

/**
 * Obtains the succeeding state-action pair, given a current tuple.
 *
 * @param s The current state-action pair.
 * @return The successor tuple.
 */
State *ExploitPlayer::nextState(State *s) {
    Maze::Actions chosenAction;
    std::tuple<State*, double> results;
    chosenAction = this->chooseAction(s);
    results = this->maze->getStateTransitionResult(s, chosenAction);
    this->rewards.push_back(std::get<1>(results));
    return std::get<0>(results);
}

/**
 * Solves the maze the player was assigned to address.
 */
void ExploitPlayer::solveMaze() {
    State *s;
    s = this->initialState();
    do {
        s = this->nextState(s);
        this->currentEpoch++;
    } while (!Player::maximumIterationReached() && !Maze::stateIsTerminal(s));
    this->maze->resetMaze();
}

/**
 * Obtains the total reward gathered by the player while solving the maze.
 *
 * @return The reward total obtained.
 */
double ExploitPlayer::getRewardTotal() {
    int rewardIndex;
    double total;
    total = 0.0;
    for (rewardIndex = 0; rewardIndex < (int)this->rewards.size(); rewardIndex++) {
        total += this->rewards[rewardIndex];
    }
    return total;
}