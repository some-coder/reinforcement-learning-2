#include "ExploitPlayer.hpp"

ExploitPlayer::ExploitPlayer(Maze *m, std::map<State*, std::vector<double>> policy) : Player(m) {
    this->currentEpoch = 0;
    this->timeoutEpoch = std::ceil(Player::EPISODE_TIMEOUT_FRACTION * this->maze->getStates()->size());
    this->policy = std::move(policy);
}

ExploitPlayer::~ExploitPlayer() = default;

State *ExploitPlayer::initialState() {
    return this->maze->getStartingState();
}

State *ExploitPlayer::nextState(State *s) {
    Maze::Actions chosenAction;
    std::tuple<State*, double> results;
    chosenAction = this->chooseAction(s);
    results = this->maze->getStateTransitionResult(s, chosenAction);
    this->rewards.push_back(std::get<1>(results));
    return std::get<0>(results);
}

void ExploitPlayer::solveMaze() {
    State *s;
    s = this->initialState();
    do {
        s = this->nextState();
        this->currentEpoch++;
    } while (!Player::maximumIterationReached() && !Maze::stateIsTerminal(s));
}

std::vector<double> ExploitPlayer::getRewards() {
    return this->rewards;
}